const exec = require('child_process').exec;
const waitUntil = require('async-wait-until');
const {includes, filter} = require('lodash');
const {readFileSync, readdirSync} = require('fs');

const PATH_TO_DAEMON = '../../daemon-build';

let logFileName;


const beforeStartSwarm = function () {
    before('swarm startup hook', async function () {
        this.timeout(3000);

        exec('cd ./daemon-resources/scripts; ./run-daemon.sh bluzelle.json');

        // Waiting briefly before starting second Daemon ensures the first starts as leader
        setTimeout(() => {
            exec('cd ./daemon-resources/scripts; ./run-daemon.sh bluzelle2.json')
        }, 1000);


        await waitUntil(() => logFileName = logFileExists());

        process.env.emulatorQuiet ||
        console.log(`******** logFileName: ${logFileName} *******`);

        await waitUntil(() => {
            let contents = readFileSync('../../daemon-build/output/' + logFileName, 'utf8');

            // raft.cpp:582 stdouts 'I AM LEADER'
            return includes(contents, 'raft.cpp:582');
        });
    });
};

const afterKillSwarm = function () {
    after(async () => {
        exec('pkill -2 swarm');
        await waitUntil(() => logFileMoved(logFileName));
    });
};

const logFileExists = () => {
    // Log file is generated by Daemon in /output folder
    return filter(logDirContent('/output'), file => includes(file, '.log'))[0];
};

const logFileMoved = () => {
    // Log file is moved to /output/logs after Daemon is stopped
    return filter(logDirContent('/output/logs'), files => includes(files, logFileName))[0];
};

const readFile = (dirPath) => {
    return readFileSync(PATH_TO_DAEMON + dirPath + logFileName, 'utf8');
};

const logDirContent = path =>
    readdirSync(PATH_TO_DAEMON + path);

module.exports = {
    beforeStartSwarm,
    afterKillSwarm,
    logFileExists,
    logFileMoved,
    readFile,
    logDirContent
};
